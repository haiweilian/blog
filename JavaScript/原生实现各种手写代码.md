---
title: 原生实现各种手写代码
date: 2021-02-26 20:40:56
updated: 2021-02-26 20:40:56
categories: JavaScript
---

## 实现 promise 简易版

```js
// 实现方案：初始化、收集回调，执行回调。
// 定义 Promise 的三种状态
const PENDING = "pending";
const RESOLVED = "resolved";
const REJECTED = "rejected";

class MyPromise {
  constructor(resolver) {
    // 当前的状态默认 pending
    this.state = PENDING;
    // value 变量用于保存 resolve 或者 reject 中传入的值
    this.value = undefined;
    // 用于保存 then 和 catch 中的回调
    this.resolvedCallbacks = [];
    this.rejectedCallbacks = [];
    // 执行 resolver 函数，接收 resolve 和 reject 参数
    resolver(this.resolve.bind(this), this.reject.bind(this));
  }

  // 1、首先必须是 pending 状态，并将状态更改为对应的状态
  // 2、将传入的值赋值给 value
  // 3、执行对应的回调数组
  // Promise 的 resolve 参数
  resolve(value) {
    setTimeout(() => {
      if (this.state === PENDING) {
        this.state = RESOLVED;
        this.value = value;
        this.resolvedCallbacks.map(cb => cb(value));
      }
    });
  }

  // Promise 的 reject 参数
  reject(value) {
    setTimeout(() => {
      if (this.state === PENDING) {
        this.state = REJECTED;
        this.value = value;
        this.rejectedCallbacks.map(cb => cb(value));
      }
    });
  }

  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数
  then(onFulfilled, onRejected) {
    // 不传时候的默认函数
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : v => v;
    onRejected = typeof onRejected === "function" ? onRejected : v => v;
    // 保存回调函数
    if (this.state === PENDING) {
      this.resolvedCallbacks.push(onFulfilled);
      this.rejectedCallbacks.push(onRejected);
    }
    return this;
  }

  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
}

// ============================== 测试 ==============================
// === 原生
let p = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(1);
  }, 1000);
});

p.then(result => {
  console.log(result);
}).catch(error => {
  console.log(error);
});

// === 实现
let p1 = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    resolve(2);
  }, 1000);
});

p1.then(result => {
  console.log(result);
}).catch(error => {
  console.log(error);
});
```

## 实现 call 函数

```js
// 实现方案：
// 1、不传入第一个参数，那么上下文默认为 window
// 2、改变 this 指向，让新的对象可以执行该函数，并能接受参数
// 3、重点就是：让函数被 context 调用。
Function.prototype.myCall = function(context) {
  // 1、判断是不是函数调用。
  if (typeof this !== "function") {
    throw new TypeError(this);
  }

  // 2、context 为可选参数，默认不传为 window。
  context = context || window;

  // 3、给 context 添加一个属性，值为需要调用的函数。
  context.fn = this;

  // 4、获取剩余的参数
  const args = [...arguments].slice(1);

  // 5、调用函数并返回结果，此时 fn 的调用者是 context，所以重新绑定了 this
  const result = context.fn(...args);

  // 6、删除函数
  delete context.fn;

  return result;
};

// ============================== 测试 ==============================
function callText(msg) {
  console.log(msg, this.val);
}

callText("callText");
callText.call({ val: 1 }, "callText");
callText.myCall({ val: 2 }, "callText");
```

## 实现 apply 函数

```js
// 实现方案：
// 1、不传入第一个参数，那么上下文默认为 window
// 2、改变 this 指向，让新的对象可以执行该函数，并能接受参数
// 3、重点就是：让函数被 context 调用。
Function.prototype.myApply = function(context) {
  // 1、判断是不是函数调用。
  if (typeof this !== "function") {
    throw new TypeError(this);
  }

  // 2、context 为可选参数，默认不传为 window。
  context = context || window;

  // 3、给 context 添加一个属性，值为需要调用的函数。
  context.fn = this;

  // 4、获取剩余的参数，参数处理和 call 有区别，
  // 5、调用函数并返回结果，此时 fn 的调用者是 context，所以重新绑定了 this
  let result;
  if (arguments[1]) {
    result = context.fn(arguments[1]);
  } else {
    result = context.fn();
  }

  // 6、删除函数
  delete context.fn;

  return result;
};

// ============================== 测试 ==============================
function applyText(msg) {
  console.log(msg, this.val);
}

applyText(["applyText"]);
applyText.apply({ val: 1 }, ["applyText"]);
applyText.myApply({ val: 2 }, ["applyText"]);
```

## 实现 bind 函数

```js
// 实现方案：
// 1、bind 返回一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式。
Function.prototype.myBind = function(context) {
  // 1、判断是不是函数调用。
  if (typeof this !== "function") {
    throw new TypeError(this);
  }

  // 2、保存 this 和截取剩余参数
  const _this = this;
  const args = [...arguments].slice(1);

  // 返回一个函数
  return function F() {
    // 因为返回一个函数，可以使用 new F()，所以需要判断。
    if (this instanceof F) {
      // 通过 new 的方式 this 就是当前实例
      return new _this(...args, ...arguments);
    } else {
      // 直接调用的方式 this 是 context
      return _this.apply(context, args.concat(...arguments));
    }
  };
};

// ============================== 测试 ==============================
function bindText(msg) {
  console.log(msg, this.val);
}

bindText("bindText");
bindText.bind({ val: 1 }, "bindText")();
bindText.myBind({ val: 2 }, "bindText")();

let np = bindText.bind({ val: 1 }, "bindText");
let np1 = bindText.myBind({ val: 2 }, "bindText");
new np();
new np1();
```

## 实现 new 操作符

```js
// 实现方案：
// 1、生成一个对象
// 2、链接到原型
// 3、绑定 this
// 4、返回新对象
function create() {
  let obj = {};
  let Con = [].shift.call(arguments);
  // 这个新对象内部的 [[Prototype]](__proto__) 特性被赋值为构造函数的 prototype 属性。
  obj.__proto__ = Con.prototype;
  // 绑定 this
  let result = Con.apply(obj, arguments);
  // 如果构造函数返回非空对象，则返回改对象；否则：返回刚创建的对象
  return result instanceof Object ? result : obj;
}

// ============================== 测试 ==============================
function newText() {
  this.a = 1;
}

let n1 = new newText();
console.log(n1.a);

let n2 = create(newText);
console.log(n2.a);
```

## 实现 instanceof 操作符

```js
// 实现方案：
// instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype
// 1、获取类型（实例）的原型 和 对象的原型
// 2、然后一直循环判断对象的原型是否等于类型的原型，直到类型原型为 null 或相等结束。
function myInstanceof(left, right) {
  let prototype = right.prototype;
  left.__proto__;
  while (true) {
    if (left === null || left === undefined) {
      return false;
    } else if (left === prototype) {
      return true;
    } else {
      left = left.__proto__;
    }
  }
}

let n = new Number(1);

console.log(n instanceof Number);
console.log(myInstanceof(n, Number));
console.log(n instanceof Boolean);
console.log(myInstanceof(n, Boolean));
```

## 实现防抖函数

```js
// 实现方案：
// _函数防抖：如果短时间内大量触发同一事件，只会执行一次函数。_
// 1、返回一个内部函数。
// 2、每次调用内部函数都清除上次的定时器让上次未执行的函数清除掉。
function debounce(fn, delay) {
  let timer = null;

  return function() {
    let arg = arguments;

    // 每次操作时，清除上传的定时器
    clearTimeout(timer);
    timer = null;

    // 定义新的定时器，一段时间后进行操作
    timer = setTimeout(function() {
      fn.apply(this, arg);
    }, delay);
  };
}

let count = 0;
let handerCount = function() {
  count++;
};

// 代理原始函数
let debounceCount = debounce(handerCount, 500);

// 开始频繁操作，数字不会变
let timer = setInterval(() => {
  debounceCount();
  console.log(count);
}, 100);

// 停止频繁操作，500ms 后数字变化
setTimeout(() => {
  clearInterval(timer);
  setTimeout(() => {
    console.log(count);
  }, 500);
}, 2000);
```

## 实现节流函数

```js
// 实现方案：
// _函数节流：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效_
// 1、返回一个内部函数。
// 2、每次调用内部函数先判断上次的函数是否执行完毕，如果未执行完毕直接返回。
function throttle(fn, delay) {
  let timer = null;

  return function() {
    let arg = arguments;

    // 如果上次执行的时间间隔未到，不执行下一次。
    if (timer) {
      return;
    }

    timer = setTimeout(function() {
      fn.apply(this, arg);
      clearTimeout(timer);
      timer = null;
    }, delay);
  };
}

let count = 0;
let handerCount = function() {
  count++;
};

// 代理原始函数
let throttleCount = throttle(handerCount, 500);

// 开始频繁操作，间隔 500ms 数字才会变
let timer = setInterval(() => {
  throttleCount();
  console.log(count);
}, 100);
```

## 实现柯里化函数

```js
// 实现方案：
// 柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。
// 所谓"柯里化"，就是把一个多参数的函数，转化为单参数函数。

// === 柯里化之前
function add(x, y) {
  return x + y;
}

console.log(add(1, 2)); // 3

// === 柯里化之后
function addX(y) {
  return function(x) {
    return x + y;
  };
}

console.log(addX(2)(1)); // 3
```

## 实现组合函数

```js
// 实现方案：
// 如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做"函数的合成"（compose）。
// 合成的好处显而易见，它让代码变得简单而富有可读性，同时通过不同的组合方式，我们可以轻易组合出其他常用函数，让我们的代码更具表现力。

function f1(arg) {
  console.log("f1", arg);
  return arg + "f1";
}

function f2(arg) {
  console.log("f2", arg);
  return arg + "f2";
}

function f3(arg) {
  console.log("f3", arg);
  return arg + "f3";
}

function f4(arg) {
  console.log("f4", arg);
  return arg + "f4";
}

function compose(...funcs) {
  // 没有传入函数参数，就返回一个默认函数（直接返回参数）
  if (funcs.length === 0) {
    return arg => arg;
  }
  // 单元素数组时调用 reduce，会直接返回该元素，不会执行callback; 所以这里手动执行
  if (funcs.length === 1) {
    return funcs[0];
  }
  // 依次拼凑执行函数
  // reduce回调函数第一次执行时，返回值为 函数 (...args) => f4(f3(...args))，作为下一次执行的a参数
  // 回调函数第二次执行时，返回值为 函数(...args) => f4(f3(f2(...args))),作为下一次执行的a参数
  // 回调函数第三次执行时，返回值为 函数(...args) => f4(f3(f2(f1(...args))))
  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}

let res = compose(f4, f3, f2, f1)("omg"); //f4(f3(f2(f1("omg"))));

console.log(res); // omgf1f2f3f4
```
