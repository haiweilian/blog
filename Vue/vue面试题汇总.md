---
title: vue面试题汇总
date: 2020-06-21
updated: 2020-06-21
categories: Vue
---

## 配合思维导图便于理解

[vue技术栈思维导图](./vue技术栈思维导图.md)

## v-if和v-for哪个优先级更高？如果两个同时出现，应该怎么优化得到更好的性能？

1. v-for 优先于 v-if 被解析，因为在源码中 v-for 优先被解析。

2. 如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能。

3. 要避免出现这种情况，则在外层嵌套 template ，在这一层进行 v-if 判断，然后在内部进行 v-for 循环。

4. 如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项。

## vue组件data为什么必须是个函数而Vue的根实例则没有此限制？

1. vue组件可能存在多个实例，如果使用对象形式定义 data ，则会导致它们共用一个 data 对象，那么状态变更将会影响所有组件实例，造成数据污染。

2. 采用函数形式定义，在 initData(vue源码的初始化函数) 时会将其作为工厂函数返回全新 data 对象，有效规避多实例之间状态污染问题。

3. 而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。

## 你知道vue中key的作用和工作原理吗？

1. key 的作用主要是为了高效的更新虚拟DOM，其原理是 vue 在 patch 过程中通过 key 可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个 patch 过程更加高效，减少DOM操 作量，提高性能。 

2. 若不设置 key 还可能在列表更新时引发一些隐蔽的bug。

3. vue中在使用相同标签名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。

## 你怎么理解vue中的diff算法？

1. diff 算法是虚拟DOM技术的必然产物：通过新旧虚拟DOM作对比（即diff），将变化的地方更新在真 实DOM上；另外，也需要diff高效的执行对比过程，从而降低时间复杂度为O(n)。 

2. vue 2.x 中为了降低 Watcher 粒度，每个组件只有一个 Watcher 与之对应，只有引入 diff 才能精确找到发生变化的地方。 

3. vue 中 diff 执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果 oldVnode 和新的渲染 结果 newVnode，此过程称为 patch。 

4. diff 过程整体遵循深度优先、同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同操作；比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次比对尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；借助 key 通常可以非常精确找到相同节点，因此整个 patch 过程非常高效。 

## 谈一谈对vue组件化的理解？

1. 组件是独立和可复用的代码组织单元。组件系统是 Vue 核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用。

2. 组件化开发能大幅提高应用开发效率、测试性、复用性等。

3. 组件使用按分类有：页面组件、业务组件、通用组件。

4. vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于 VueComponent ，扩展于Vue。

5. vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等； 

6. 合理的划分组件，有助于提升应用性能。

7. 组件应该是高内聚、低耦合的。

8. 遵循单向数据流的原则。 

## 谈一谈对vue设计原则的理解？

1. [官网](https://cn.vuejs.org/)上的定义和特点：渐进式JavaScript框架、易用、灵活、高效。

2. 渐进式JavaScript框架：与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使 用时，Vue 也完全能够为复杂的单页应用提供驱动。 

3. 易用性：vue 提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js、html和css就能轻松编写vue应用。

3. 灵活性：渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能；随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli等库和工具，不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。

4. 高效性：超快的虚拟DOM 和 diff 算法使我们的应用拥有最佳的性能表现。

## 你了解哪些vue性能优化方法？

1. 路由懒加载。

2. keep-alive 缓存页面。

3. 频繁切换使用 v-show 复用DOM。

3. v-for 遍历避免同时使用 v-if。

4. 如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化（Object.freeze()）。

5. 如果是大数据长列表，可采用虚拟滚动技术，只渲染少部分区域的内容。

6. 事件的销毁，Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如定义的定时器，需要销毁前清除。

7. 图片懒加载，对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载，等到滚动到可视区域后再去加载。

8. 第三方插件按需引入，像 element-ui 这样的第三方组件库可以按需引入避免体积太大。

9. 无状态的组件标记为函数式组件。

10. 服务端渲染SSR。

## vue中组件之间的通信方式？

1. vue组件中通信的几种方式：props、$emit/$on、$parent/$children、$attrs/$listeners、provide/inject、vuex。

2. vue组件之间通信场景：父子组件通信、兄弟组件通信 、跨层组件通信。

## 说一说vue响应式理解？

1. 什么是响应式：数据发生变化后，会重新对页面渲染，这就是Vue响应式。想完成这个过程，我们需要，*数据劫持/数据代理*（侦测数据的变化）、*依赖收集*（收集视图依赖了哪些数据）、*发布订阅*（数据变化时，自动“通知”需要更新的视图部分，并进行更新）。

2. 响应式实现：Object.defineProperty、Proxy(Vue3的方案)。data 通过 Observer 转换成了 getter/setter 的形式来追踪变化。 当外界通过 Watcher 读取数据的，会触发 getter 从而将 watcher 添加到依赖中。当数据变化时，会触发 setter 从而向 Dep 中的依赖（watcher）发送通知。 watcher 接收通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。

## vue为什么要求组件模版只能有一个根元素?

1. new Vue({el:'#app'})，需要指定一个入口。

2. 单文件组件中，template 下的元素 div。其实就是"树"状数据结构中的"根"。 

3. diff算法要求的，源码中 patch.js 里 patchVnode()。

## 你知道nextTick的原理吗?

1. vue用异步队列的方式来控制DOM更新和 nextTick 回调先后执行。

2. microtask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕。

3. 因为兼容性问题，vue不得不做了 microtask 向 macrotask 的降级方案。
